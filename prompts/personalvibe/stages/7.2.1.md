# python prompts/personalvibe/stages/7.2.1.py

#!/usr/bin/env python3
"""
Sprint 7.4.0: Testing and Documentation for Developer Experience Enhancements

This script creates comprehensive tests and documentation for:
1. New bugfix mode functionality
2. CLI enhancements (new-milestone, prepare-sprint, prepare-bugfix)
3. Model selection and LLM routing
4. Improved error handling and logging
"""

import textwrap
from pathlib import Path
from personalvibe import vibe_utils

REPO = vibe_utils.get_base_path()

# Test for color formatting in logger
test_color_formatter = '''
# Copyright © 2025 by Nick Jenkins. All rights reserved

"""Test color formatting functionality in logger."""

import logging
import sys
from io import StringIO
from unittest import mock

from personalvibe import logger
from personalvibe.logger import ColorFormatter


def test_color_formatter_formats_correctly():
    """Test that ColorFormatter adds correct ANSI codes."""
    formatter = ColorFormatter("%(levelname)s - %(message)s")
    
    # Create a log record
    record = logging.LogRecord(
        name="test",
        level=logging.INFO,
        pathname="test.py",
        lineno=1,
        msg="Test message",
        args=(),
        exc_info=None
    )
    
    formatted = formatter.format(record)
    # Should contain green color code for INFO
    assert "\\033[92m" in formatted
    assert "INFO" in formatted
    assert "\\033[0m" in formatted  # Reset code


def test_color_formatter_all_levels():
    """Test color codes for all log levels."""
    formatter = ColorFormatter("%(levelname)s")
    
    test_cases = [
        (logging.DEBUG, "\\033[94m"),    # Blue
        (logging.INFO, "\\033[92m"),     # Green
        (logging.WARNING, "\\033[93m"),  # Yellow
        (logging.ERROR, "\\033[91m"),    # Red
        (logging.CRITICAL, "\\033[95m"), # Magenta
    ]
    
    for level, expected_color in test_cases:
        record = logging.LogRecord(
            name="test", level=level, pathname="", lineno=0,
            msg="", args=(), exc_info=None
        )
        formatted = formatter.format(record)
        assert expected_color in formatted


def test_configure_logging_with_color(tmp_path):
    """Test that color is enabled by default."""
    logger.reset_logging()
    
    # Capture stdout to check if color codes are present
    captured_output = StringIO()
    
    with mock.patch("sys.stdout", captured_output):
        logger.configure_logging("verbose", color=True)
        log = logging.getLogger("test_color")
        log.info("Colored message")
    
    # Reset for other tests
    logger.reset_logging()
'''

# Test for progress indicators and better error messages
test_dx_improvements = '''
# Copyright © 2025 by Nick Jenkins. All rights reserved

"""Test developer experience improvements."""

import time
from pathlib import Path
from unittest import mock

import pytest

from personalvibe import run_pipeline, vibe_utils
from personalvibe.run_pipeline import ConfigModel, ValidationError


def test_config_validation_helpful_errors(tmp_path):
    """Test that config validation provides actionable error messages."""
    bad_yaml = tmp_path / "bad.yaml"
    bad_yaml.write_text("""
        project_name: test
        mode: invalid_mode
        execution_details: ""
        code_context_paths: []
    """, encoding="utf-8")
    
    with pytest.raises(ValidationError) as exc_info:
        run_pipeline.load_config(str(bad_yaml))
    
    # Check that error message mentions valid modes
    error_str = str(exc_info.value)
    assert "mode" in error_str.lower()
    assert "prd|milestone|sprint|validate|bugfix" in error_str


def test_missing_project_name_helpful_error(tmp_path, monkeypatch):
    """Test helpful error when project_name is missing and can't be detected."""
    yaml_no_project = tmp_path / "no_project.yaml"
    yaml_no_project.write_text("""
        mode: sprint
        execution_details: ""
        code_context_paths: []
    """, encoding="utf-8")
    
    # Make auto-detection fail
    monkeypatch.setattr(vibe_utils, "detect_project_name", 
                       lambda: (_ for _ in ()).throw(ValueError("No project found")))
    
    with pytest.raises(RuntimeError) as exc_info:
        run_pipeline.load_config(str(yaml_no_project))
    
    assert "project_name absent" in str(exc_info.value)
    assert "auto-detection failed" in str(exc_info.value)


def test_model_validation_error_message():
    """Test that model field validation provides clear error."""
    from pydantic import ValidationError
    
    with pytest.raises(ValidationError) as exc_info:
        ConfigModel(
            version="1.0.0",
            project_name="test",
            mode="sprint",
            model="invalid-model-format",
            execution_details="",
            code_context_paths=[]
        )
    
    error_str = str(exc_info.value)
    assert "model must be <provider>/<model_name>" in error_str


def test_file_not_found_context_paths(tmp_path, monkeypatch):
    """Test clear error when code_context_paths file doesn't exist."""
    base = tmp_path / "repo"
    base.mkdir()
    
    context_file = base / "context.txt"
    context_file.write_text("nonexistent_file.py\\n", encoding="utf-8")
    
    monkeypatch.setattr(vibe_utils, "get_base_path", lambda: base)
    
    with pytest.raises(ValueError) as exc_info:
        vibe_utils.get_context(["context.txt"])
    
    error_msg = str(exc_info.value)
    assert "nonexistent_file.py" in error_msg
    assert "does not exist" in error_msg


def test_progress_logging_milestones(caplog):
    """Test that important operations log progress at INFO level."""
    import logging
    
    # Test prompt saving logs
    prompt = "Test prompt content"
    root_dir = Path("/tmp/test_prompts")
    
    with mock.patch("personalvibe.vibe_utils.Path.mkdir"):
        with mock.patch("personalvibe.vibe_utils.Path.write_text"):
            with mock.patch("personalvibe.vibe_utils.find_existing_hash", return_value=None):
                with caplog.at_level(logging.INFO):
                    vibe_utils.save_prompt(prompt, root_dir)
    
    assert any("Prompt saved to:" in record.message for record in caplog.records)
'''

# Test for CLI prepare-bugfix command
test_prepare_bugfix_cli = '''
# Copyright © 2025 by Nick Jenkins. All rights reserved

"""Test the prepare-bugfix CLI command."""

from pathlib import Path

from personalvibe import cli, vibe_utils


def test_prepare_bugfix_creates_yaml(monkeypatch, tmp_path):
    """Test that prepare-bugfix creates correct YAML file."""
    root = tmp_path / "repo"
    stages = root / "prompts" / "testproject" / "stages"
    stages.mkdir(parents=True)
    
    # Create existing sprint files
    (stages / "1.0.0.md").write_text("Milestone 1")
    (stages / "1.1.0.py").write_text("# Sprint 1")
    
    monkeypatch.chdir(root)
    monkeypatch.setattr(vibe_utils, "get_base_path", lambda: root)
    
    # Run prepare-bugfix
    cli.cli_main(["prepare-bugfix", "--project_name", "testproject", "--no-open"])
    
    # Check that bugfix YAML was created with correct version
    bugfix_yaml = root / "1.1.1.yaml"
    assert bugfix_yaml.exists()
    
    content = bugfix_yaml.read_text()
    assert "project_name: testproject" in content
    assert "mode: bugfix" in content


def test_prepare_bugfix_increments_correctly(monkeypatch, tmp_path):
    """Test that bugfix versions increment the patch number."""
    root = tmp_path / "repo"
    stages = root / "prompts" / "demo" / "stages"
    stages.mkdir(parents=True)
    
    # Create existing files including a bugfix
    (stages / "2.3.0.py").write_text("# Sprint")
    (stages / "2.3.1.md").write_text("# Bugfix 1")
    (stages / "2.3.2.md").write_text("# Bugfix 2")
    
    monkeypatch.chdir(root)
    monkeypatch.setattr(vibe_utils, "get_base_path", lambda: root)
    
    cli.cli_main(["prepare-bugfix", "--project_name", "demo", "--no-open"])
    
    # Should create 2.3.3.yaml
    next_bugfix = root / "2.3.3.yaml"
    assert next_bugfix.exists()


def test_prepare_bugfix_no_existing_files(monkeypatch, tmp_path):
    """Test prepare-bugfix when no stage files exist yet."""
    root = tmp_path / "repo"
    stages = root / "prompts" / "newproject" / "stages"
    stages.mkdir(parents=True)
    
    monkeypatch.chdir(root)
    monkeypatch.setattr(vibe_utils, "get_base_path", lambda: root)
    
    cli.cli_main(["prepare-bugfix", "--project_name", "newproject", "--no-open"])
    
    # Should create 1.0.1.yaml as first bugfix
    first_bugfix = root / "1.0.1.yaml"
    assert first_bugfix.exists()
'''

# Integration test for complete bugfix workflow
test_bugfix_integration = '''
# Copyright © 2025 by Nick Jenkins. All rights reserved

"""Integration test for complete bugfix workflow."""

import subprocess
import sys
from pathlib import Path
from unittest import mock

import pytest

from personalvibe import cli, run_pipeline, vibe_utils


@pytest.mark.advanced
def test_bugfix_complete_workflow(monkeypatch, tmp_path):
    """Test complete bugfix workflow from YAML to execution."""
    root = tmp_path / "testproj"
    prompts = root / "prompts" / "testbug"
    stages = prompts / "stages"
    stages.mkdir(parents=True)
    
    # Create PRD template
    prd = prompts / "prd.md"
    prd.write_text("""# {{ project_name }} PRD

Task: {{ execution_task }}

{{ instructions }}

Error Details:
{{ error_details }}

Code context:
{{ code_context }}
""", encoding="utf-8")
    
    # Create milestone
    (stages / "1.0.0.md").write_text("# Milestone 1: Initial implementation")
    
    # Create bugfix config
    bugfix_yaml = root / "1.0.1.yaml"
    bugfix_yaml.write_text("""
project_name: testbug
mode: bugfix
execution_details: |
  Fix ImportError in module loader
  Error: cannot import name 'missing_func' from 'mymodule'
code_context_paths: []
""", encoding="utf-8")
    
    monkeypatch.setattr(vibe_utils, "get_base_path", lambda: root)
    monkeypatch.setenv("PV_DATA_DIR", str(root))
    
    # Mock the template loader
    def mock_load_template(fname):
        if fname == "bugfix.md":
            return """# Bugfix Mode Instructions

You are fixing a bug in version {{ project_name }} {{ execution_task }}.

Error details:
{{ error_details }}

Please analyze the error and provide a minimal fix.
"""
        return "Mock template"
    
    monkeypatch.setattr(vibe_utils, "_load_template", mock_load_template)
    
    # Run in prompt_only mode
    monkeypatch.setattr(sys, "argv", [
        "pv", "bugfix", "--config", str(bugfix_yaml), "--prompt_only"
    ])
    
    try:
        run_pipeline.main()
    except SystemExit:
        pass
    
    # Verify prompt was created with bugfix content
    prompt_dir = root / "data" / "testbug" / "prompt_inputs"
    assert prompt_dir.exists()
    
    prompts = list(prompt_dir.glob("*.md"))
    assert len(prompts) > 0
    
    prompt_content = prompts[0].read_text()
    assert "fix the bug described in version" in prompt_content
    assert "ImportError" in prompt_content
    assert "missing_func" in prompt_content
'''

# Test for parse-stage bugfix file naming
test_parse_stage_bugfix_naming = '''
# Copyright © 2025 by Nick Jenkins. All rights reserved

"""Test parse-stage handles bugfix .md file naming correctly."""

from pathlib import Path

from personalvibe import parse_stage, vibe_utils


def test_parse_stage_bugfix_extension(monkeypatch, tmp_path):
    """Test that bugfix versions get .md extension."""
    root = tmp_path / "repo"
    outputs = root / "data" / "proj" / "prompt_outputs"
    stages = root / "prompts" / "proj" / "stages"
    outputs.mkdir(parents=True)
    stages.mkdir(parents=True)
    
    # Create existing files to establish version
    (stages / "1.2.0.py").write_text("# sprint")
    (stages / "1.2.1.md").write_text("# bugfix 1")
    
    # Create a mock assistant output
    output_file = outputs / "2024-01-01_12-00-00_abc123.md"
    output_file.write_text("""
Assistant response with code:

<python>
# Fix for the bug
import os
print("Bug fixed!")
