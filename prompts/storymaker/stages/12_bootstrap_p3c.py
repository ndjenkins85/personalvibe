# Copyright © 2025 by Nick Jenkins. All rights reserved

# python prompts/storymaker/stages/12_bootstrap_p3c.py

#!/usr/bin/env python
"""
Bootstrap — Chunk C (React *typed fetch* layer)

Run this script **once** from *any* folder inside the repo.
It will:

1. Locate the git root via `personalvibe.vibe_utils.get_base_path()`
2. Create / update the SPA fetch-layer files:
      • storymaker_spa/src/api/types.ts
      • storymaker_spa/src/api/mock.ts
      • storymaker_spa/src/api/client.ts   (over-writes old slim stub)
3. Leave the rest of the code-base untouched.
4. Print concise next-steps for running the SPA with either:
      • real Flask backend (`Authorization: DEV`) or
      • in-browser mock API (`VITE_API_MOCK=true`)
"""

from __future__ import annotations

import textwrap
from pathlib import Path

from personalvibe import vibe_utils

REPO = vibe_utils.get_base_path()


# ──────────────────────────────────────────────────────────────────────
# Helper – write file only if contents have changed
# ──────────────────────────────────────────────────────────────────────
def write(path: Path, content: str) -> None:
    if path.exists() and path.read_text(encoding="utf-8") == content:
        print(f"✓ {path.relative_to(REPO)} unchanged")
        return
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")
    print(f"✎ Wrote {path.relative_to(REPO)}")


# ──────────────────────────────────────────────────────────────────────
# 1. Typed DTOs (mirrors Flask Pydantic schemas)
# ──────────────────────────────────────────────────────────────────────
types_ts = (
    textwrap.dedent(
        """
    /* Auto-generated by Chunk C (React fetch layer).  Edit manually if backend schemas evolve. */
    // Generic “{ status, data, meta }” envelope returned by API
    export interface ApiResponse<T> {
      status: 'ok';
      data: T;
      meta?: Pagination;
    }

    export interface Pagination {
      page: number;
      per_page: number;
      total: number;
      pages?: number;
    }

    // ────────────────────────────────────────────
    // Domain models (Book, Character …)
    // ────────────────────────────────────────────
    export type CharacterType = 'adult' | 'child' | 'toy';

    export interface Character {
      id: string;
      name: string;
      type: CharacterType;
      description: string;
      avatar_path?: string | null;
      created_at: string;           // ISO-8601
    }

    export interface Book {
      id: string;
      name: string;
      description: string;
      created_at: string;
      cover_image?: string | null;
      page_count: number;
    }

    // ────────────────────────────────────────────
    // Auth DTOs
    // ────────────────────────────────────────────
    export interface LoginResponse {
      access_token: string;
      token_type: string;   // "bearer"
    }

    export interface MeResponse {
      id: string;
      email: string;
      display_name: string;
    }
    """
    ).strip()
    + "\n"
)

# ──────────────────────────────────────────────────────────────────────
# 2. Tiny in-memory mock server (for offline UI dev & Storybook)
# ──────────────────────────────────────────────────────────────────────
mock_ts = (
    textwrap.dedent(
        """
    /* Lightweight mock API – toggled via VITE_API_MOCK=true */
    import { ApiResponse, Book, Character } from './types';

    function delay(ms: number) { return new Promise(r => setTimeout(r, ms)); }

    const characters: Character[] = [
      {
        id: '1111',
        name: 'Plushie Duck',
        type: 'toy',
        description: 'Soft yellow plush',
        created_at: new Date().toISOString(),
      },
    ];

    const books: Book[] = [
      {
        id: 'b-demo',
        name: 'Demo Book',
        description: 'Generated by mock API',
        created_at: new Date().toISOString(),
        cover_image: undefined,
        page_count: 10,
      },
    ];

    export default async function mockFetch<T>(path: string, opts: RequestInit = {}): Promise<T> {
      await delay(120);                           // simulate latency
      const { method = 'GET' } = opts;

      // ---------------------- Books ----------------------
      if (path.startsWith('/api/books') && method === 'GET')
        return { status: 'ok', data: books } as ApiResponse<Book[]> as unknown as T;

      if (path.startsWith('/api/books') && method === 'POST')
        return { status: 'ok', data: { book_id: 'new-book-id' } } as unknown as T;

      // ------------------- Characters --------------------
      if (path.startsWith('/api/characters') && method === 'GET')
        return { status: 'ok', data: characters } as ApiResponse<Character[]> as unknown as T;

      if (path.startsWith('/api/characters') && method === 'POST')
        return { status: 'ok', data: { character_id: 'new-char-id' } } as unknown as T;

      // ---------------------- Auth -----------------------
      if (path === '/api/login' && method === 'POST')
        return { status: 'ok', data: { access_token: 'mock-jwt', token_type: 'bearer' } } as unknown as T;

      if (path == '/api/me' && method === 'GET')
        return {
          status: 'ok',
          data: { id: '0000', email: 'dev@local', display_name: 'Mock Dev' },
        } as unknown as T;

      throw new Error(`mockFetch: unhandled route ${method} ${path}`);
    }
    """
    ).strip()
    + "\n"
)

# ──────────────────────────────────────────────────────────────────────
# 3. Typed fetch wrapper (replaces previous minimal stub)
# ──────────────────────────────────────────────────────────────────────
client_ts = (
    textwrap.dedent(
        """
    /* Storymaker – typed fetch layer (Chunk C)

       – Thin wrapper over window.fetch with:
         • Automatic JSON marshaling / error bubbling
         • Generic <T> helpers
         • Run-time switch between real backend & in-memory mock (VITE_API_MOCK=true)
    */
    import type {
      ApiResponse,
      Book,
      Character,
      LoginResponse,
      MeResponse,
    } from './types';

    const API_BASE = import.meta.env.VITE_API_BASE ?? 'http://localhost:8777';
    const USE_MOCK = import.meta.env.VITE_API_MOCK === 'true';

    // -------------------- Real network --------------------
    async function realFetch<T>(path: string, opts: RequestInit = {}): Promise<T> {
      const res = await fetch(`${API_BASE}${path}`, {
        headers: {
          'Content-Type': 'application/json',
          ...(opts.headers || {}),
        },
        ...opts,
      });

      // Gracefully handle non-JSON responses
      const data = await res.json().catch(() => ({}));

      if (!res.ok) {
        // The Flask error handler uses { error, code } – surface that
        const msg = data?.error ?? res.statusText ?? 'Unknown error';
        throw new Error(msg);
      }
      return data as T;
    }

    // -------------------- Mock layer ----------------------
    import mockFetch from './mock';
    const baseFetch = USE_MOCK ? mockFetch : realFetch;

    // -------------------- API helpers ---------------------
    // Feel free to extend – component code stays type-safe.

    // Books ------------------------------------------------
    export const listBooks       = () => baseFetch<ApiResponse<Book[]>>('/api/books',   { headers: { Authorization: 'DEV' } });
    export const createBook      = (payload: any) =>
      baseFetch<ApiResponse<{ book_id: string }>>('/api/books', {
        method: 'POST',
        body: JSON.stringify(payload),
        headers: { Authorization: 'DEV' },
      });

    // Characters ------------------------------------------
    export const listCharacters  = () => baseFetch<ApiResponse<Character[]>>('/api/characters', { headers: { Authorization: 'DEV' } });
    export const createCharacter = (payload: any) =>
      baseFetch<ApiResponse<{ character_id: string }>>('/api/characters', {
        method: 'POST',
        body: JSON.stringify(payload),
        headers: { Authorization: 'DEV' },
      });

    // Auth -------------------------------------------------
    export const login           = (email: string, password = '') =>
      baseFetch<ApiResponse<LoginResponse>>('/api/login', {
        method: 'POST',
        body: JSON.stringify({ email, password }),
      });

    export const me              = (token: string) =>
      baseFetch<ApiResponse<MeResponse>>('/api/me', {
        headers: { Authorization: `Bearer ${token}` },
      });

    // Export default for ad-hoc fetches
    export default baseFetch;
    """
    ).strip()
    + "\n"
)

# ──────────────────────────────────────────────────────────────────────
# 4. Write files
# ──────────────────────────────────────────────────────────────────────
api_dir = REPO / "storymaker_spa" / "src" / "api"
write(api_dir / "types.ts", types_ts)
write(api_dir / "mock.ts", mock_ts)
write(api_dir / "client.ts", client_ts)

# ──────────────────────────────────────────────────────────────────────
# 5. Developer guidance
# ──────────────────────────────────────────────────────────────────────
print(
    """
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ Chunk C ready – typed fetch layer installed.

Next steps:

1.  (optional)  Develop UI fully offline:
      cd storymaker_spa
      VITE_API_MOCK=true  npm run dev

    The React app will use the in-memory mock routes defined in
    `src/api/mock.ts`, so no backend server is required.

2.  Run against the real Flask API:
      # Terminal 1
      poetry run python -m storymaker.api.app  # → http://localhost:8777

      # Terminal 2
      cd storymaker_spa
      npm run dev                              # → http://localhost:5173

    All requests automatically include the special
    `Authorization: DEV` header accepted by the backend during local
    development.  Edit `src/api/client.ts` if you later implement a
    real login flow.

3.  Change TypeScript interfaces when backend DTOs evolve.  Front-end
    components will get *compile-time* errors instead of silent
    runtime surprises.

Happy hacking! 🚀
"""
)
