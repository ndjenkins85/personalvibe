# Copyright Â© 2025 by Nick Jenkins. All rights reserved

# python prompts/storymaker/stages/12_bootstrap_p3c.py

#!/usr/bin/env python
"""
Bootstrap â€” Chunk C (React *typed fetch* layer)

Run this script **once** from *any* folder inside the repo.
It will:

1. Locate the git root via `personalvibe.vibe_utils.get_base_path()`
2. Create / update the SPA fetch-layer files:
      â€¢ storymaker_spa/src/api/types.ts
      â€¢ storymaker_spa/src/api/mock.ts
      â€¢ storymaker_spa/src/api/client.ts   (over-writes old slim stub)
3. Leave the rest of the code-base untouched.
4. Print concise next-steps for running the SPA with either:
      â€¢ real Flask backend (`Authorization: DEV`) or
      â€¢ in-browser mock API (`VITE_API_MOCK=true`)
"""

from __future__ import annotations

import textwrap
from pathlib import Path

from personalvibe import vibe_utils

REPO = vibe_utils.get_base_path()


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Helper â€“ write file only if contents have changed
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def write(path: Path, content: str) -> None:
    if path.exists() and path.read_text(encoding="utf-8") == content:
        print(f"âœ“ {path.relative_to(REPO)} unchanged")
        return
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")
    print(f"âœ Wrote {path.relative_to(REPO)}")


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 1. Typed DTOs (mirrors Flask Pydantic schemas)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
types_ts = (
    textwrap.dedent(
        """
    /* Auto-generated by Chunk C (React fetch layer).  Edit manually if backend schemas evolve. */
    // Generic â€œ{ status, data, meta }â€ envelope returned by API
    export interface ApiResponse<T> {
      status: 'ok';
      data: T;
      meta?: Pagination;
    }

    export interface Pagination {
      page: number;
      per_page: number;
      total: number;
      pages?: number;
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Domain models (Book, Character â€¦)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    export type CharacterType = 'adult' | 'child' | 'toy';

    export interface Character {
      id: string;
      name: string;
      type: CharacterType;
      description: string;
      avatar_path?: string | null;
      created_at: string;           // ISO-8601
    }

    export interface Book {
      id: string;
      name: string;
      description: string;
      created_at: string;
      cover_image?: string | null;
      page_count: number;
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Auth DTOs
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    export interface LoginResponse {
      access_token: string;
      token_type: string;   // "bearer"
    }

    export interface MeResponse {
      id: string;
      email: string;
      display_name: string;
    }
    """
    ).strip()
    + "\n"
)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 2. Tiny in-memory mock server (for offline UI dev & Storybook)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
mock_ts = (
    textwrap.dedent(
        """
    /* Lightweight mock API â€“ toggled via VITE_API_MOCK=true */
    import { ApiResponse, Book, Character } from './types';

    function delay(ms: number) { return new Promise(r => setTimeout(r, ms)); }

    const characters: Character[] = [
      {
        id: '1111',
        name: 'Plushie Duck',
        type: 'toy',
        description: 'Soft yellow plush',
        created_at: new Date().toISOString(),
      },
    ];

    const books: Book[] = [
      {
        id: 'b-demo',
        name: 'Demo Book',
        description: 'Generated by mock API',
        created_at: new Date().toISOString(),
        cover_image: undefined,
        page_count: 10,
      },
    ];

    export default async function mockFetch<T>(path: string, opts: RequestInit = {}): Promise<T> {
      await delay(120);                           // simulate latency
      const { method = 'GET' } = opts;

      // ---------------------- Books ----------------------
      if (path.startsWith('/api/books') && method === 'GET')
        return { status: 'ok', data: books } as ApiResponse<Book[]> as unknown as T;

      if (path.startsWith('/api/books') && method === 'POST')
        return { status: 'ok', data: { book_id: 'new-book-id' } } as unknown as T;

      // ------------------- Characters --------------------
      if (path.startsWith('/api/characters') && method === 'GET')
        return { status: 'ok', data: characters } as ApiResponse<Character[]> as unknown as T;

      if (path.startsWith('/api/characters') && method === 'POST')
        return { status: 'ok', data: { character_id: 'new-char-id' } } as unknown as T;

      // ---------------------- Auth -----------------------
      if (path === '/api/login' && method === 'POST')
        return { status: 'ok', data: { access_token: 'mock-jwt', token_type: 'bearer' } } as unknown as T;

      if (path == '/api/me' && method === 'GET')
        return {
          status: 'ok',
          data: { id: '0000', email: 'dev@local', display_name: 'Mock Dev' },
        } as unknown as T;

      throw new Error(`mockFetch: unhandled route ${method} ${path}`);
    }
    """
    ).strip()
    + "\n"
)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 3. Typed fetch wrapper (replaces previous minimal stub)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
client_ts = (
    textwrap.dedent(
        """
    /* Storymaker â€“ typed fetch layer (Chunk C)

       â€“ Thin wrapper over window.fetch with:
         â€¢ Automatic JSON marshaling / error bubbling
         â€¢ Generic <T> helpers
         â€¢ Run-time switch between real backend & in-memory mock (VITE_API_MOCK=true)
    */
    import type {
      ApiResponse,
      Book,
      Character,
      LoginResponse,
      MeResponse,
    } from './types';

    const API_BASE = import.meta.env.VITE_API_BASE ?? 'http://localhost:8777';
    const USE_MOCK = import.meta.env.VITE_API_MOCK === 'true';

    // -------------------- Real network --------------------
    async function realFetch<T>(path: string, opts: RequestInit = {}): Promise<T> {
      const res = await fetch(`${API_BASE}${path}`, {
        headers: {
          'Content-Type': 'application/json',
          ...(opts.headers || {}),
        },
        ...opts,
      });

      // Gracefully handle non-JSON responses
      const data = await res.json().catch(() => ({}));

      if (!res.ok) {
        // The Flask error handler uses { error, code } â€“ surface that
        const msg = data?.error ?? res.statusText ?? 'Unknown error';
        throw new Error(msg);
      }
      return data as T;
    }

    // -------------------- Mock layer ----------------------
    import mockFetch from './mock';
    const baseFetch = USE_MOCK ? mockFetch : realFetch;

    // -------------------- API helpers ---------------------
    // Feel free to extend â€“ component code stays type-safe.

    // Books ------------------------------------------------
    export const listBooks       = () => baseFetch<ApiResponse<Book[]>>('/api/books',   { headers: { Authorization: 'DEV' } });
    export const createBook      = (payload: any) =>
      baseFetch<ApiResponse<{ book_id: string }>>('/api/books', {
        method: 'POST',
        body: JSON.stringify(payload),
        headers: { Authorization: 'DEV' },
      });

    // Characters ------------------------------------------
    export const listCharacters  = () => baseFetch<ApiResponse<Character[]>>('/api/characters', { headers: { Authorization: 'DEV' } });
    export const createCharacter = (payload: any) =>
      baseFetch<ApiResponse<{ character_id: string }>>('/api/characters', {
        method: 'POST',
        body: JSON.stringify(payload),
        headers: { Authorization: 'DEV' },
      });

    // Auth -------------------------------------------------
    export const login           = (email: string, password = '') =>
      baseFetch<ApiResponse<LoginResponse>>('/api/login', {
        method: 'POST',
        body: JSON.stringify({ email, password }),
      });

    export const me              = (token: string) =>
      baseFetch<ApiResponse<MeResponse>>('/api/me', {
        headers: { Authorization: `Bearer ${token}` },
      });

    // Export default for ad-hoc fetches
    export default baseFetch;
    """
    ).strip()
    + "\n"
)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 4. Write files
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
api_dir = REPO / "storymaker_spa" / "src" / "api"
write(api_dir / "types.ts", types_ts)
write(api_dir / "mock.ts", mock_ts)
write(api_dir / "client.ts", client_ts)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 5. Developer guidance
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
print(
    """
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… Chunk C ready â€“ typed fetch layer installed.

Next steps:

1.  (optional)  Develop UI fully offline:
      cd storymaker_spa
      VITE_API_MOCK=true  npm run dev

    The React app will use the in-memory mock routes defined in
    `src/api/mock.ts`, so no backend server is required.

2.  Run against the real Flask API:
      # Terminal 1
      poetry run python -m storymaker.api.app  # â†’ http://localhost:8777

      # Terminal 2
      cd storymaker_spa
      npm run dev                              # â†’ http://localhost:5173

    All requests automatically include the special
    `Authorization: DEV` header accepted by the backend during local
    development.  Edit `src/api/client.ts` if you later implement a
    real login flow.

3.  Change TypeScript interfaces when backend DTOs evolve.  Front-end
    components will get *compile-time* errors instead of silent
    runtime surprises.

Happy hacking! ğŸš€
"""
)
